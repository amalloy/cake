#!/usr/bin/env ruby
# Save your fork, there's cake!"
require 'ftools'
require 'find'
require 'open-uri'
require 'rexml/document'
require 'socket'
require 'timeout'
require 'readline'

file     = File.readlink(__FILE__) rescue __FILE__
$cakedir = File.dirname(File.dirname(file))
$confdir = ".cake"
$repo    = "http://clojars.org/repo/cake/cake"

def get_cake(version, dest)
  jar  = version =~ /(.*)-SNAPSHOT/ ? "cake-#{$1}-#{snapshot(version)}.jar" : "cake-#{version}.jar"
  dest = File.expand_path(dest)
  path = "#{dest}/#{jar}"

  if not File.exists?(path)
    puts "fetching cake libraries. this may take a moment..."
    url = "#{$repo}/#{version}/#{jar}"
    File.makedirs(dest)
    open(url) do |jar|
      open(path, "wb") do |file|
        while (buf = jar.read(8192))
          file.write buf
        end
      end
    end
  end
  path
rescue OpenURI::HTTPError => e
  puts "unable to find cake version #{version} on clojars."
  puts "please check http://github.com/ninjudd/cake for latest install instructions."
  exit
end

def current_version
  open("#{$repo}/maven-metadata.xml") do |file|
    doc = REXML::Document.new file
    doc.elements['metadata'].elements['versioning'].elements['versions'].elements.to_a('version').last.get_text.to_s
  end
end

def snapshot(version)
  open("#{$repo}/#{version}/maven-metadata.xml") do |file|
    doc = REXML::Document.new file
    snapshot  = doc.elements['metadata'].elements['versioning'].elements['snapshot'].elements
    timestamp = snapshot['timestamp'].get_text
    build_num = snapshot['buildNumber'].get_text
    "#{timestamp}-#{build_num}"
  end
end

def extract(jar, file)
  dest = File.dirname(jar)
  system %{ jar xf #{jar} -C #{dest} #{file} }
  "#{dest}/#{file}"
end

def debug?
  ENV['DEBUG'] || ENV['debug']
end

def daemon(cmd)
  pid = fork do
    Process.setsid
    if not debug?
      STDIN.reopen  '/dev/null'
      STDOUT.reopen '/dev/null', 'a'
      STDERR.reopen '/dev/null', 'a'
    end
    exec(cmd)
  end
  Process.detach(pid)
  pid
end

def pidfile(type)
  "#{$confdir}/#{type}.pid"
end

def modtime(path)
  if path.kind_of?(Array)
    path.collect {|f| modtime(f)}.max
  elsif File.directory?(path)
    modtime = Time.at(0)
    Find.find(path) do |file|
      modtime = [modtime, File.mtime(file)].max if File.exists?(file)
    end
    modtime
  else
    File.mtime(path) if File.exists?(path)
  end || Time.at(0)
end

def restart?(type, classpath)
  start_time = modtime(pidfile(type))

  files = classpath.split(':').collect do |path|
    path = "#{path}.jar" if path =~ /\*$/
    Dir[path]
  end
  files.concat ["project.clj", "build.clj"] if type == :cake

  modtime(files) > start_time
end

def read_config(type)
  if File.exists?($confdir)
    begin
      pid, port = IO.read(pidfile(type)).map {|l| l.to_i}
      Process.kill(0, pid) # make sure pid is valid
      [pid, port]
    rescue Errno::ENOENT => e # no pidfile
      []
    rescue Errno::ESRCH => e # invalid pid
      File.unlink(pidfile(type))
      []
    end
  else
    File.makedirs($confdir)
  end
end

MIN_PORT = 2**13
MAX_PORT = 2**16
def start_jvm(type, classpath)
  stop_jvm(type) if restart?(type, classpath)

  pid, port = read_config(type)
  if pid.nil?
    port = rand(MAX_PORT - MIN_PORT) + MIN_PORT
    puts "starting #{type} jvm on port #{port}" if debug?
    pid  = daemon %{ java -d32 -cp #{classpath} clojure.main -e "(use '#{type})(start-server #{port})" /dev/null }
    File.open(pidfile(type), 'w') {|f| f.write("#{pid}\n#{port}\n") }
  end
  port
rescue Errno::EADDRNOTAVAIL => e
  retry
end

def stop_jvm(type, opts = {})
  pid, port = read_config(type)
  if port
    socket = TCPSocket.new("localhost", port)
    action = opts[:force] ? ":force-quit" : ":quit"
    puts "sending #{action} to #{type} server on port #{port}" if debug?
    socket.write(action + "\n")
    if socket.gets == "true\n"
      File.unlink(pidfile(type))
    else
      puts "-------------------------------------------"
      puts "warning: classes have changed but can't restart #{type} jvm with active connections"
      puts "         close active connections or use 'cake stop' to force quit"
      puts "-------------------------------------------"
    end
  end
rescue Errno::ECONNREFUSED => e
end

def connect(port)
  TCPSocket.new("localhost", port)
rescue Errno::ECONNREFUSED => e
  sleep 1
  retry
end

def send_command(command = 'default', *args)
  socket = connect($cakeport)
  socket.write("(#{command} [#{args.join(' ')}] #{$bakeport})\n")
  while(line = socket.gets)
    puts line
  end
end

MARKER = rand.to_s
PROMPT = /^(.*)#{MARKER}$/
START_REPL = <<-END
  (clojure.main/repl
    :init   #(in-ns 'user)
    :prompt #(printf "%s=> #{MARKER}\n" (ns-name *ns*)))
END

def read_until_prompt(socket)
  while line = socket.gets
    if line =~ PROMPT
      return $1
    else
      puts line
    end
  end
end

def complete?(input)
  return true if input.empty?
  socket = connect($bakeport)
  socket.write(":validate #{input}")
  socket.close_write # send eof
  socket.gets != "incomplete\n"
end

def readline(initial_prompt)
  input = ""
  prompt = initial_prompt.clone
  while line = Readline.readline(prompt)
    input << " " unless input.empty?
    input << line
    if complete?(input)
      Readline::HISTORY.push(input)
      return input
    end
    prompt[-2] = ?*
  end
rescue Interrupt => e
  return nil if input.empty?
  Readline::HISTORY.push(input)
  retry
end

HISTORY_NUM  = 500
HISTORY_FILE = ".cake/history"

def repl
  open(HISTORY_FILE) do |file|
    file.each {|line| Readline::HISTORY << line.chomp}
  end if File.exists?(HISTORY_FILE)

  loop do
    socket = connect($bakeport)
    socket.write START_REPL
    socket.gets # burn extra prompt

    while prompt = read_until_prompt(socket)
      line = readline(prompt)
      return unless line
      socket.write(line + "\n")
    end
  end
ensure
  open(HISTORY_FILE, 'w') do |file|
    history = Readline::HISTORY.to_a
    file.puts(history[-HISTORY_NUM..-1] || history)
  end
end

# Bootstap cake dependencies.
lib = "#{$cakedir}/lib"
if File.exists?("#{$cakedir}/.gitignore")
  if Dir["#{lib}/*.jar"].empty?
    # In a new git checkout, need to fetch dependencies.
    version = IO.read("#{$cakedir}/project.clj").first.match(/defproject cake \"(.*)\"/)[1]
    get_cake(version, lib)
  end
  cakepath = "#{$cakedir}/src/:#{lib}/*"
  bakepath = "#{$cakedir}/bake"
else
  cakejar = "#{lib}/cake.jar"
  bakejar = "#{lib}/bake.jar"
  if File.exists?(cakejar) and File.exists?(bakejar)
    # Inside a gem install.
    cakepath = cakejar
    bakepath = bakejar
  else
    # Naked script.
    version  = current_version
    dest     = "~/.m2/repository/cake/cake/#{version}"
    cakepath = get_cake(version, dest)
    bakepath = extract(classpath, "bake-#{version}.jar")
  end
end

if ARGV.first == 'stop'
  stop_jvm(:cake, :force => true)
  stop_jvm(:bake, :force => true)
else
  $cakeport = start_jvm(:cake, cakepath)

  if ARGV.first != 'deps' and File.exists?('project.clj')
    if not File.exists?('pom.xml') or test(?>, 'project.clj', 'pom.xml')
      send_command('deps')
    end
    pwd = Dir.getwd
    $bakeport = start_jvm(:bake, "#{bakepath}:#{pwd}/src:#{pwd}/src/clj:#{pwd}/classes:#{pwd}/lib/*")
  end

  if ARGV.first == 'repl'
    repl
  else
    send_command(*ARGV)
  end
end
