#!/usr/bin/env ruby
# Save your fork, there's cake!"
require 'ftools'
require 'find'
require 'open-uri'
require 'rexml/document'
require 'socket'
require 'timeout'
require 'readline'
require 'fileutils'
require 'pp'

file     = File.readlink(__FILE__) rescue __FILE__
$cakedir = File.dirname(File.dirname(file))
$confdir = ".cake"
$repo    = "http://clojars.org/repo/cake/cake"
File.makedirs($confdir)

def get_cake(version, dest)
  jar  = version =~ /(.*)-SNAPSHOT/ ? "cake-#{$1}-#{snapshot(version)}.jar" : "cake-#{version}.jar"
  dest = File.expand_path(dest)
  path = "#{dest}/#{jar}"

  if not File.exists?(path)
    puts "fetching cake libraries. this may take a moment..."
    url = "#{$repo}/#{version}/#{jar}"
    File.makedirs(dest)
    open(url) do |jar|
      open(path, "wb") do |file|
        while (buf = jar.read(8192))
          file.write buf
        end
      end
    end
  end
  path
rescue OpenURI::HTTPError => e
  puts "unable to find cake version #{version} on clojars."
  puts "please check http://github.com/ninjudd/cake for latest install instructions."
  exit
end

def current_version
  open("#{$repo}/maven-metadata.xml") do |file|
    doc = REXML::Document.new file
    doc.elements['metadata'].elements['versioning'].elements['versions'].elements.to_a('version').last.get_text.to_s
  end
end

def snapshot(version)
  open("#{$repo}/#{version}/maven-metadata.xml") do |file|
    doc = REXML::Document.new file
    snapshot  = doc.elements['metadata'].elements['versioning'].elements['snapshot'].elements
    timestamp = snapshot['timestamp'].get_text
    build_num = snapshot['buildNumber'].get_text
    "#{timestamp}-#{build_num}"
  end
end

def extract(jar, file)
  dest = File.dirname(jar)
  system %{ jar xf #{jar} -C #{dest} #{file} }
  "#{dest}/#{file}"
end

def verbose?
  @verbose = ARGV.any? {|arg| arg =~ /^(-?-v)|(-?-verbose)$/} if @verbose.nil?
  @verbose
end

class JVM
  attr_reader :type, :classpath, :port, :pid, :pidfile, :start_time

  def initialize(classpath)
    @type       = self.class.name.downcase
    @classpath  = classpath
    @pidfile    = "#{$confdir}/#{type}.pid"
    @start_time = File.exists?(pidfile) ? File.mtime(pidfile) : Time.now

    @pid, @port = IO.read(pidfile).map {|l| l.to_i}
    Process.kill(0, @pid) # make sure pid is valid

  rescue Errno::ESRCH, Errno::ENOENT => e
    reset! # no pidfile or invalid pid
  end

  def running?
    not pid.nil?
  end

  def init
    reload_stale_files if running?
    start
  end

  def reload_stale_files
    stale_files = files.select {|f| stale?(f)}
    return if stale_files.empty?
    puts "#{type}: the following files have changed: #{stale_files.join(', ')}" if verbose?

    if stale_files.any? {|f| File.extname(f) != ".clj"}
      stop
    else
      with_socket do |socket|
        stale_files = stale_files.collect {|f| %{"#{f}"} }
        socket.write ":reload [#{stale_files.join(" ")}]\n"
        if socket.gets
          puts "#{type}: unable to reload all files" if verbose?
          stop
        else
          FileUtils.touch(pidfile)
          @start_time = Time.now
        end
      end
    end
  end

  MIN_PORT = 2**13
  MAX_PORT = 2**16

  def start
    return if running?
    @port = rand(MAX_PORT - MIN_PORT) + MIN_PORT
    puts "#{type}: starting jvm on port #{port}" if verbose?
    @pid = daemon %{ java -d32 -cp #{classpath} clojure.main -e "(use '#{type})(start-server #{port})" /dev/null }
    File.open(pidfile, 'w') {|f| f.write("#{pid}\n#{port}\n") }

  rescue Errno::EADDRNOTAVAIL => e
    retry
  end

  def stop(opts = {})
    with_socket do |socket|
      action = opts[:force] ? ":force-quit" : ":quit"
      puts "#{type}: sending #{action} to jvm on port #{port}" if verbose?
      socket.write(action + "\n")
      line = socket.gets
      if line == "true\n"
        reset!
      else
        puts "-------------------------------------------"
        puts "warning: classes have changed but can't restart #{type} jvm with active connections"
        puts "         close active connections or use 'cake stop' to force quit"
        puts "-------------------------------------------"
      end
    end
  end

  def files
    files = []
    classpath.split(':').uniq.each do |path|
      if path =~ /(.*)\/\*$/
        files.concat Dir["#{path}.jar"] << "#{$1}/." # include the directory itself so deletions will be detected
      else
        Find.find(path) do |f|
          files << f if File.exists?(f) and not File.directory?(f)
        end
      end
    end
    files
  end

private

  def reset!
    File.unlink(pidfile) if File.exists?(pidfile)
    @pid, @port = []
    @start_time = Time.now
  end

  def stale?(file)
    File.exists?(file) and File.mtime(file) > start_time
  end

  def daemon(cmd)
    pid = fork do
      Process.setsid
      exec(cmd)
    end
    Process.detach(pid)
    pid
  end

  def with_socket(wait = false)
    return unless port
    socket = TCPSocket.new("localhost", port)
    result = yield(socket)
    socket.close
    result
  rescue Errno::ECONNREFUSED => e
    sleep 1
    retry
  end
end

class Cake < JVM
  attr_accessor :bake_port

  def files
    super.concat ["project.clj", "build.clj"]
  end

  def send_command(command, *args)
    with_socket(true) do |socket|
      socket.write("(#{command} [#{args.join(' ')}] #{bake_port})\n")
      while(line = socket.gets)
        puts line
      end
    end
  end
end

class Bake < JVM
  MARKER = rand.to_s
  PROMPT = /^(.*)#{MARKER}$/
  START_REPL = <<-END
    (clojure.main/repl
      :init   #(in-ns 'user)
      :prompt #(printf "%s=> #{MARKER}\n" (ns-name *ns*)))
  END

  def repl
    load_history
    loop do
      with_socket(true) do |socket|
        socket.write START_REPL
        socket.gets # burn extra prompt

        while prompt = read_until_prompt(socket)
          line = readline(prompt)
          return unless line
          socket.write(line + "\n")
        end
      end
    end
  ensure
    save_history
  end

private

  HISTORY_NUM  = 500
  HISTORY_FILE = ".cake/history"

  def load_history
    open(HISTORY_FILE) do |file|
      file.each {|line| Readline::HISTORY << line.chomp}
    end if File.exists?(HISTORY_FILE)
  end

  def save_history
    open(HISTORY_FILE, 'w') do |file|
      history = Readline::HISTORY.to_a
      file.puts(history[-HISTORY_NUM..-1] || history)
    end
  end

  def read_until_prompt(socket)
    while line = socket.gets
      return $1 if line =~ PROMPT
      puts line
    end
  end

  def complete?(input)
    return true if input.empty?
    with_socket(true) do |socket|
      socket.write(":validate #{input}")
      socket.close_write # send eof
      socket.gets != "incomplete\n"
    end
  end

  def readline(initial_prompt)
    input = ""
    prompt = initial_prompt.clone
    while line = Readline.readline(prompt)
      input << " " unless input.empty?
      input << line
      if complete?(input)
        Readline::HISTORY.push(input)
        return input
      end
      prompt[-2] = ?*
    end
  rescue Interrupt => e
    return nil if input.empty?
    Readline::HISTORY.push(input)
    retry
  end
end

# Bootstrap cake dependencies.
lib = "#{$cakedir}/lib"
if File.exists?("#{$cakedir}/.gitignore")
  if Dir["#{lib}/*.jar"].empty?
    # In a new git checkout, need to fetch dependencies.
    version = IO.read("#{$cakedir}/project.clj").first.match(/defproject cake \"(.*)\"/)[1]
    get_cake(version, lib)
  end
  cakepath = "#{$cakedir}/src:#{lib}/*"
  bakepath = "#{$cakedir}/bake"
else
  cakejar = "#{lib}/cake.jar"
  bakejar = "#{lib}/bake.jar"
  if File.exists?(cakejar) and File.exists?(bakejar)
    # Inside a gem install.
    cakepath = cakejar
    bakepath = bakejar
  else
    # Naked script.
    version  = current_version
    dest     = "~/.m2/repository/cake/cake/#{version}"
    cakepath = get_cake(version, dest)
    bakepath = extract(classpath, "bake-#{version}.jar")
  end
end

pwd = Dir.getwd
srcpath = "#{pwd}/src:#{pwd}/src/clj"

cake = Cake.new("#{cakepath}:#{srcpath}:#{pwd}/lib/dev/*")
bake = Bake.new("#{bakepath}:#{srcpath}:#{pwd}/classes:#{pwd}/test:#{pwd}/lib/*:#{pwd}/lib/dev/*")

command = (ARGV.first || 'default').to_sym

if [:stop, :restart].include?(command)
  cake.stop(:force => true)
  bake.stop(:force => true)

  if command == :stop
    puts "cake jvm processes stopped"
    exit
  end
end

cake.init
if command != :deps and File.exists?('project.clj')
  cake.send_command(:deps) if not File.exists?('pom.xml') or test(?>, 'project.clj', 'pom.xml')
  bake.init
  cake.init # must check if dev dependencies have changed
  cake.bake_port = bake.port
end

if [:start, :reload, :restart].include?(command)
  puts "cake jvm processes #{command}ed"
elsif command == :repl
  bake.repl
else
  cake.send_command(*ARGV)
end
