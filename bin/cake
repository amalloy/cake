#!/usr/bin/env ruby
# Save your fork, there's cake!"
require 'find'
require 'open-uri'
require 'rexml/document'
require 'socket'
require 'timeout'
require 'fileutils'
require 'io/wait'
require 'pp'

if RUBY_PLATFORM =~ /(mingw|mswin)(32|64)$/
  require 'win32/process'
  TERM = 'BRK'
  KILL = 'KILL'
  PATH_SEP = ';'
  $home = ENV['HOMEDRIVE'] + ENV['HOMEPATH']
  $win  = true

  def daemon(cmd)
    Process.create(:app_name => cmd).process_id
  end
else
  TERM = 'TERM'
  KILL = 'KILL'
  PATH_SEP = ':'
  $home = File.expand_path("~")

  class Process::Error; end
  def daemon(cmd)
    puts cmd if debug?
    pid = fork do
      Process.setsid
      exec(cmd)
    end
    Process.detach(pid)
    pid
  end
end

begin
  require 'readline'
rescue LoadError => e
  module Readline
    HISTORY = []
    attr_accessor :basic_word_break_characters, :completion_proc
    def readline(prompt)
      $stdout.print prompt
      $stdout.flush
      $stdin.gets
    end
    extend Readline
  end
end

class IO
  def gets_nonblock(delim = "\n")
    line = ""
    while c = read_nonblock(1)
      line << c
      break if c == delim
    end
    line
  rescue Errno::EAGAIN, EOFError => e
    line
  end
end

def add_opt!(key, *vals)
  ($opts[key.to_sym] ||= []).concat vals
end

def parse_opts!
  ARGV.unshift('run', '--global') if ARGV.first.index('/')
  ARGV.unshift('default') if ARGV.empty? or ARGV.first[0,1] == '-'
  $command = ARGV.shift.to_sym
  $opts = {}
  ARGV.each do |opt|
    case opt
    when /^-(\w+)$/              then $1.split('').each {|c| add_opt!(c, '')}
    when /^--?([-\w]+)=([\S]+)$/ then add_opt!($1, *$2.split(','))
    when /^--?([-\w]+)$/         then add_opt!($1, "")
    else                              add_opt!($command, opt)
    end
  end
  $opts.freeze
end
parse_opts!

def debug?
  ENV['CAKE_DEBUG'] or $opts[:d] or $opts[:debug]
end

def verbose?
  debug? or $opts[:v] or $opts[:verbose]
end

def restart?
  $opts[:r] or $opts[:restart] or [:stop, :restart].include?($command)
end

def admin_command?
  [:start, :stop, :reload, :restart].include?($command)
end

def log(command, *message)
  message.each do |line|
    printf("%11s %s\n", "[#{command}]", line)
  end
end

class Configuration < Hash
  def initialize(*paths)
    paths.each do |path|
      File.open(path, 'r') do |file|
        file.each do |line|
          next if ['#', '!'].include?(line[0,1])
          key, value = line.split('=', 2)
          next unless key and value
          self[key.strip] = value.strip
        end
      end if File.exists?(path)
    end
  end

  def [](*keys)
    if keys.first.kind_of?(Symbol)
      key = keys.join('.') + '.'
      clone.delete_if {|k,v| not k.index(key) == 0}
    else
      super
    end
  end
end

def config
  @config ||= Configuration.new("#{$home}/.cake/config", ".cake/config")
end

if debug?
  puts "opts: #{$opts.inspect}"
  puts "config: #{$config.inspect}"
end

GLOBAL_DEFAULT_PROJECT = <<END
(defproject global "0.0.0"  
  :description "Don't rename this project, though you can change the version to your heart's content."
  :dependencies [[clojure "1.2.0-RC2"]
                 [clojure-contrib "1.2.0-RC2"]])
;;--------------------
;; This is the global cake project. What does that mean?
;;  1. This project is used whenever you run cake outside a project directory.
;;  2. Any dependencies specified here will be available in the global repl.
;;  3. Any dev-dependencies specified here will be available in all projects, though you
;;     must run 'cake deps --global' manually when you change this file.
;;  4. Configuration options in ~/.cake/config are used in all projects.
;;--------------------
END

def project_dir(dir)
  if $opts[:project] and not $opts[:global]
    project = $opts[:project].last
    raise "project dir #{project} does not exist" unless File.exists?(project)
    return project
  end

  while dir != File.dirname(dir)
    return dir if ["project.clj", "tasks.clj"].any? {|file| File.exists?("#{dir}/#{file}")}
    dir = File.dirname(dir)
  end unless $opts[:global]
  project_dir = "#{$home}/.cake"
  project_clj = "#{project_dir}/project.clj"
  FileUtils.makedirs(project_dir) unless File.exists?(project_dir)
  File.open(project_clj, 'w') {|f| f.write(GLOBAL_DEFAULT_PROJECT)} unless File.exists?(project_clj)
  project_dir
end

def readlink(file)
  File.readlink(file)
rescue NotImplementedError, Errno::EINVAL
  file
end

$pwd     = Dir.getwd
$bakedir = project_dir($pwd)
$cakedir = File.dirname(File.dirname(readlink(__FILE__)))
$repo    = "http://clojars.org/repo/cake/cake"
$confdir = ".cake"
Dir.chdir($bakedir)
FileUtils.makedirs($confdir)

def get_cake(version, dest = nil, opts = {})
  jar  = version =~ /(.*)-SNAPSHOT/ ? "cake-#{$1}-#{snapshot(version)}.jar" : "cake-#{version}.jar"
  repo = File.expand_path("~/.m2/repository/cake/cake/#{version}")
  path = "#{repo}/#{jar}"

  if not File.exists?(path)
    log(:deps, "fetching cake libraries. this may take a moment...") unless @logged; @logged = true
    url = "#{$repo}/#{version}/#{jar}"
    log(:deps, "downloading #{url}") if verbose?
    FileUtils.makedirs(repo)
    open(url) do |jarfile|
      open(path, "wb") do |file|
        while (buf = jarfile.read(8192))
          file.write buf
        end
      end
    end
  end
  return path unless dest

  dest = File.expand_path(dest)
  FileUtils.makedirs(dest)
  FileUtils.copy(path, dest)
  "#{dest}/#{jar}"
rescue OpenURI::HTTPError => e
  raise if opts[:raise]
  log(:deps, "unable to find cake version #{version} on clojars.")
  log(:deps, "please check http://github.com/ninjudd/cake for latest install instructions.")
  exit
end

def current_version
  open("#{$repo}/maven-metadata.xml") do |file|
    doc = REXML::Document.new file
    doc.elements['metadata'].elements['versioning'].elements['versions'].elements.to_a('version').last.get_text.to_s
  end
end

def snapshot(version)
  open("#{$repo}/#{version}/maven-metadata.xml") do |file|
    doc = REXML::Document.new file
    snapshot  = doc.elements['metadata'].elements['versioning'].elements['snapshot'].elements
    timestamp = snapshot['timestamp'].get_text
    build_num = snapshot['buildNumber'].get_text
    "#{timestamp}-#{build_num}"
  end
end

def extract(jar, file, dest = File.dirname(jar))
  if not File.exists?("#{dest}/#{file}")
    log(:deps, "extracting #{file} from #{jar}") if verbose?
    ret = system "jar xf #{jar} #{file}"
    raise "cannot find jar command" unless ret
    FileUtils.makedirs(dest)
    FileUtils.move(file, dest)
  end
  "#{dest}/#{file}"
end

def newer?(file1, file2)
  return false unless File.exists?(file1)
  not File.exists?(file2) or test(?>, file1, file2)
end

def ps
  `jps -v`.split("\n").select {|l| l =~ /cake\.project/}
end

class JVM
  attr_reader :type, :classpath, :libpath, :port, :pid, :pidfile, :load_time

  def initialize(classpath, libpath)
    @type       = self.class.name.downcase
    @classpath  = make_path(classpath)
    @libpath    = make_path(libpath)
    @pidfile    = "#{$confdir}/#{type}.pid"
    @load_time = File.exists?(pidfile) ? File.mtime(pidfile) : Time.now
    refresh
  end

  def running?
    not pid.nil?
  end

  def enabled?
    true
  end

  def init
    stale = reload_stale_files if enabled? and running?
    start
    stale
  end

  def refresh
    @pid, @port = IO.read(pidfile).split("\n").map {|l| l.to_i}
    Process.kill(0, @pid) # make sure pid is valid
    TCPSocket.new("localhost", @port).close if @port # make sure jvm is running on port
  rescue Errno::ENOENT, Errno::ESRCH, Errno::ECONNREFUSED, Errno::EBADF, Process::Error => e
    log(:start, "defunct #{type} jvm") if debug? and e.kind_of?(Errno::ECONNREFUSED)
    reset! # no pidfile or invalid pid or connection refused
  end

  def reload
    refresh
    init
  end

  def with_restart
    stop
    yield
    start
  end

  def reload_stale_files
    stale_files = files.select {|f| stale?(f)}

    if stale_files.empty?
      log(:reload, "no stale #{type} files found") if verbose? and admin_command?
      false
    else
      log(:reload, "the following #{type} files have changed: #{stale_files.join(', ')}") if debug?

      if stale_files.any? {|f| File.extname(f) != ".clj"}
        log(:reload, "non-clojure #{type} files have changed, restarting") if verbose?
        stop(:reload)
      else
        log(:reload, "clojure #{type} files have changed, reloading") if verbose?
        with_socket(nil) do |socket|
          stale_files = stale_files.collect {|f| %{"#{f}"} }
          socket.write ":reload [#{stale_files.join(" ")}]\n"
          if socket.eof?
            FileUtils.touch(pidfile)
            @load_time = Time.now
          else
            inspect(socket)
            log(:reload, "unable to reload all #{type} files, restarting") if verbose?
            stop(:reload)
          end
        end
      end
      true
    end
  end

  def java_opts
    opts =  %{-cp "#{classpath}" -Djava.library.path="#{libpath}"}
    opts << %{ -Djava.home="#{ENV['JAVA_HOME']}" -Djava.ext.dirs="#{ENV['JAVA_HOME']}/lib"} if ENV['JAVA_HOME']
    opts
  end

  MIN_PORT = 2**14
  MAX_PORT = 2**16

  def start
    return unless enabled?
    if running?
      log(:start, "#{type} jvm already running") if $command == :start
      return
    else
      log(:start, "starting #{type} jvm") if verbose? or $command == :start
      @port = rand(MAX_PORT - MIN_PORT) + MIN_PORT
      @pid = daemon %{java -Dcake.project="#{$bakedir}" #{java_opts} clojure.main -e "(use '#{type})(start-server #{port})"}
      File.open(pidfile, 'w') {|f| f.write("#{pid}\n#{port}\n") }
    end
  rescue Errno::EADDRNOTAVAIL => e # port already in use
    retry
  end

  def stop(mode = :stop)
    return unless running?
    with_socket(nil) do |socket|
      action = mode == :reload ? 'quit' : 'force-quit'
      log(mode, "sending #{action} to #{type} jvm on port #{port}") if debug?
      socket.write(":#{action}\n")
      if socket.eof?
        log(mode, "#{type} jvm stopped") if restart?
        reset!
      else
        inspect(socket)
        if mode == :stop
          log(mode, "error stopping #{type} jvm, try 'cake kill' or 'cake kill -9'")
        else
          log(mode, "close active connections or use 'cake stop' to force quit")
        end
      end
    end || (log(mode, "#{type} jvm not running") if $command == :stop)
  end

  def kill
    Process.kill($opts[:"9"] ? KILL : TERM, pid) if pid
  end

  def files
    files = ["project.clj", "#{$home}/.cake/config", ".cake/config"]
    classpath.split(PATH_SEP).uniq.each do |path|
      if path =~ /(.*)\/\*$/
        files.concat Dir["#{path}.jar"] << "#{$1}/." # include the directory itself so deletions will be detected
      else
        Find.find(path) do |f|
          Find.prune if f == "#{$bakedir}/src/jvm"
          files << f if File.exists?(f) and not File.directory?(f)
        end if File.exists?(path)
      end
    end
    files
  end

  def ping
    return unless enabled?
    with_socket do |socket|
      socket.write ":ping\n"
      log($command, "#{type} jvm not running") unless socket.gets == "pong\n"
    end
  end

  REPL_PROMPT = "REPL_PROMPT__#{rand}"
  def repl
    load_history
    loop do
      with_socket do |socket|
        socket.write %{:repl "#{REPL_PROMPT}"}
        while @ns = read_until_prompt(socket)
          line = readline
          return unless line
          socket.write(line + "\n")
        end
      end
    end
  ensure
    save_history
  end

  def eval(forms = $opts[:eval])
    forms = forms.collect do |form|
      form == '-' ? $stdin.gets(nil) : form
    end.join(' ')
    with_socket do |socket|
      log(:eval, forms) if debug?
      socket.write(':eval [' + forms + ']')
      while (line = socket.gets)
        puts line
      end
    end
  end

private

  def make_path(paths)
    paths.flatten.compact.join(PATH_SEP)
  end

  def inspect(socket)
    line = socket.gets
    if debug? or not line.start_with?('reload-failed:')
      puts line
      while line = socket.gets
        puts line
      end
    end
  end

  def reset!
    File.unlink(pidfile) if File.exists?(pidfile)
    @pid, @port = []
    @load_time = Time.now
  end

  def stale?(file)
    File.exists?(file) and File.mtime(file) > load_time
  end

  def with_socket(retries = 20)
    return unless port
    socket = TCPSocket.new("localhost", port)
    result = yield(socket)
    result
  rescue Errno::ECONNREFUSED, Errno::EBADF => e
    sleep 1
    if retries
      retry if (retries -= 1) >= 0
      log($command, "timeout while connecting to #{type} jvm")
      exit
    end
  ensure
    socket.close if socket
  end

  HISTORY_NUM  = 500
  HISTORY_FILE = ".cake/history"
  def load_history
    open(HISTORY_FILE) do |file|
      file.each {|line| Readline::HISTORY << line.chomp}
    end if File.exists?(HISTORY_FILE)
  end

  def save_history
    open(HISTORY_FILE, 'w') do |file|
      history = Readline::HISTORY.to_a
      file.puts(history[-HISTORY_NUM..-1] || history)
    end
  end

  def read_until_prompt(socket, wait = 0.01, read_timeout = 3)
    prompt = nil
    while read_timeout -= wait
      while socket.wait(wait)
        line = socket.gets_nonblock
        if line =~ /^#{REPL_PROMPT}(.*)$/
          prompt = $1
        else
          $stdout.print line
          $stdout.flush
        end
      end
      break if prompt

      while $stdin.ready?
        socket.puts($stdin.gets)
      end if read_timeout <= 0
    end
    prompt
  end

  def validate(input)
    return input if input.empty?
    with_socket do |socket|
      socket.write(":validate #{input.join("\n").strip}")
      socket.close_write # send eof
      results = socket.gets(nil)

      return if results == "incomplete\n"
      if results == "invalid\n"
        input.join(' ').strip
      else
        results.strip
      end
    end
  end

  Readline.basic_word_break_characters = " \t\n\"'`~@;#&{}()[]"
  def readline
    input = []
    prompt = "#{@ns}=> "
    Readline.completion_proc = method(:completions)
    while line = Readline.readline(prompt)
      input << line
      if valid_input = validate(input)
        Readline::HISTORY.push(valid_input)
        return valid_input
      end
      prompt[-2] = ?*
    end
  rescue Interrupt => e
    return nil if input.empty?
    Readline::HISTORY.push(input)
    retry
  end

  def completions(prefix)
    return [] if prefix.empty?
    with_socket do |socket|
      socket.write(":completions [\"#{prefix}\" #{@ns}]\n")
      completions = []
      while line = socket.gets
        completions << line.chomp
      end
      completions
    end
  end
end

class Cake < JVM
  attr_accessor :bakeport

  READLINE = "READLINE__#{rand}"
  def send_command(command, args = [])
    with_restart { FileUtils.remove_dir("lib/dev", true) } if $win and [:deps, :clean].include?(command)

    with_socket do |socket|
      args = args.collect{|arg| '"' + arg.gsub('"', '\"').gsub("\n", "\\n") + '"'}
      env  = command == :run ? ('{' + ENV.collect {|k,v| "#{k.inspect} #{v.inspect}"}.join(' ') + '}') : 'nil'
      cmd  = %{[#{command} [#{args.join(' ')}] #{bakeport || 'nil'} "#{$pwd}" #{env}] "#{READLINE}"}
      log(command, "sending: " + cmd) if debug?
      socket.write(cmd)
      while (line = socket.gets)
        if line =~ /^#{READLINE}(.*)$/
          socket.write(prompt($1))
        elsif line =~ /^@#{READLINE}(.*)$/
          socket.write(prompt($1, :echo => false))
        else
          puts line
        end
      end
    end
  end

  def files
    super.concat ["build.clj", "#{$home}/.cake/tasks.clj"]
  end

  def java_opts
    [ENV['CAKE_JAVA_OPTS'], config['cake.java_opts'], super].compact.join(' ')
  end

private

  def prompt(prompt, opts = {})
    if opts[:echo] == false
      echo_off = system("stty -echo 2&> /dev/null")
      prompt << " (WARNING, input will be visible on console!)" unless echo_off
    end
    input = Readline.readline(prompt + ": ") || ''
    input + "\n"
  ensure
    if echo_off
      system("stty echo 2&> /dev/null")
      puts
    end
  end
end

class Bake < JVM
  def java_opts
    [ENV['JAVA_OPTS'], config['project.java_opts'], super].compact.join(' ')
  end

  def enabled?
    Dir["lib/*.jar"].any?
  end
end

# Bootstrap cake dependencies.
lib = "#{$cakedir}/lib"
if File.exists?("#{$cakedir}/.gitignore") and File.exists?("#{$cakedir}/project.clj")
  if Dir["#{lib}/*.jar"].empty? or Dir["#{lib}/dev/*.jar"].empty?
    # In a new git checkout, need to fetch dependencies.
    begin
      version = IO.read("#{$cakedir}/project.clj").split("\n").first.match(/defproject cake \"(.*)\"/)[1]
      cakejar = get_cake(version, lib, :raise => true)
    rescue OpenURI::HTTPError => e
      version = current_version
      cakejar = get_cake(version, lib)
    end
    extract(cakejar, "bake-#{version}.jar", "#{lib}/dev")
  end

  cakepath = ["#{$cakedir}/src", "#{lib}/*:#{lib}/dev/*"].join(PATH_SEP)
  bakepath = ["#{$cakedir}/bake", "#{lib}/dev/*"].join(PATH_SEP)
else
  cakejar = "#{lib}/cake.jar"
  bakejar = "#{lib}/bake.jar"
  if File.exists?(cakejar) and File.exists?(bakejar)
    # Inside a gem install.
    cakepath = cakejar
    bakepath = bakejar
  else
    # Naked script.
    version  = current_version
    cakepath = get_cake(version)
    bakepath = extract(cakepath, "bake-#{version}.jar")
  end
end

cake = Cake.new(
  [cakepath, "src", "src/clj", config['cake.claspath'], "lib/dev/*", "#{$home}/.cake/lib/dev/*"],
  [config['cake.library.path'], "lib/dev/native"]
)
bake = Bake.new(
  [bakepath, "src", "src/clj", "classes", "test", config['project.classpath'], "lib/*", "lib/dev/*", "#{$home}/.cake/lib/dev/*"],
  [config['project.library.path'], "lib/native", "lib/dev/native"]
)

if $command == :kill
  if $opts[:all]
    ps.each do |line|
      pid = line.split(' ').first.to_i
      Process.kill($opts[:"9"] ? KILL : TERM, pid)
    end
  else
    cake.kill
    bake.kill
  end
  exit
elsif $command == :ps
  puts ps.sort.reverse
  exit
elsif restart?
  cake.stop
  bake.stop
  exit if $command == :stop
end

cake.init
if [:deps, :clean].include?($command)
  bake.stop
elsif File.exists?('project.clj')
  if newer?('project.clj', 'pom.xml') or not bake.enabled?
    bake.stop
    cake.send_command(:deps)
    cake.init
  elsif config['swank.auto-start'] or config['swank']
    cake.send_command(:"swank-deps")
    cake.init
  end

  bake.init
end

if [:repl, :eval].include?($command)
  if $opts[:cake] or not File.exists?('project.clj')
    cake.send($command)
  else
    bake.send($command)
  end
elsif [:start, :reload, :restart].include?($command)
  if $opts[:l] or $opts[:log]
    system("touch .cake/project.log")
    system("tail -f .cake/project.log")
  else
    cake.ping
    bake.ping
  end
else
  cake.bakeport = bake.port
  if $command == :autotest
    cake.send_command(:autotest)
    interval = $opts[:autotest].last.to_i if $opts[:autotest]
    interval = interval || (config['autotest.interval'].to_i if config['autotest.interval']) || 1
    run_tests = true
    ran = false
    while true
      args = ["--auto"]
      if ran == false
        args << "--report"
        ran = true
      end
      cake.send_command(:test, args) if run_tests
      run_tests = bake.reload
      cake.reload
      sleep(interval)
    end
  else
    cake.send_command($command, ARGV)
  end
end
